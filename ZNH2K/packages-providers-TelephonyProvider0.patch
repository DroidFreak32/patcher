From 1f56701610d7105f0313c4fc39ddba779fd26d9d Mon Sep 17 00:00:00 2001
From: Sultanxda <sultanxda@gmail.com>
Date: Thu, 28 Jul 2016 13:38:43 -0700
Subject: [PATCH] Squashed commit of the following:

commit 057cbb3c443c389fff7c928405d324c23f81dbab
Author: Richard LIU <richardl@codeaurora.org>
Date:   Fri Dec 19 16:24:37 2014 +0800

    TelephonyProvider: Add CDMA call forwarding/waiting function

    Add CDMA call forwarding/waiting function. CdmaCallOptionProvider
    has only one instance in the phone process, also has the same user
    id with phone process. Following scenes has been tested:
     - Has same user id but different process id with
    phone process, for example, the telecom.
     - Has didfferent user id with phone process, for
    example, the dialer.

    Change-Id: I1305a6effa99a30cbaf1d716470c388d9866f9ba
    CRs-Fixed: 748144

commit 615e785fa0f404bd4935e83cc71c63ed5de83d19
Author: Susheel nyamala <snyamala@codeaurora.org>
Date:   Fri May 8 17:57:50 2015 +0530

    Merge regional apns to telephony db

    Carrier specific regional apns are provided with a delta apns
    xml file. These apns must be updated to telephony db.

    Change-Id: I783d8a659659ac4cd4bbfbcacdd3d6f9ba69f207
    CRs-Fixed: 812350

commit 2ab318f9fe1f3326c1108bb164c5b8b1bb14e82e
Author: Susheel nyamala <snyamala@codeaurora.org>
Date:   Wed Oct 28 13:37:18 2015 +0530

    Fix Mms failures due to wrong numeric

    In TelephonyProvider, where mms apn is queried for mmsc url from
    telephony apns db, sometimes mcc-mnc value read from getSimOperator
    method is wrong for uicc card with multiple apps.
    Replace getSimOperator with getIccOperatorNumericForData method,
    which gets mcc-mnc value based on PS RAT registered.

    Change-Id: Ida4d8e33dd85e08b4bd09b5053d3803a7689d55f
    CRs-Fixed: 930607

commit 09632e8998858f28e818605ed4ecb8eb8b1c7348
Author: Sridhar Dubbaka <sdubbaka@codeaurora.org>
Date:   Wed Oct 21 14:16:44 2015 +0530

    [CellBroadcast Alerts] : Enable CMAS Test alerts

    Enable CDMA Test alerts  by default.

    Change-Id: Ice852bf9e710665d695c30d01cf89349b3a35b5a
    CRs-Fixed: 926432

commit 1752a04b5489b75235d41a2f8d3fc2fe42c021b5
Author: Sridhar Dubbaka <sdubbaka@codeaurora.org>
Date:   Tue Sep 22 22:23:59 2015 +0530

    [TelephonyProvider]: Add Channel 60 support

    Add Channel 60 column to siminfo table.

    Change-Id: I85d805c998f1878d8fb30e6e867c2781518aaca2

Change-Id: I7e8a935230c6c8a9417e3a7ca1616a845243667e
---
 AndroidManifest.xml                                |   4 +
 .../telephony/CdmaCallOptionProvider.java          | 450 +++++++++++++++++++++
 .../providers/telephony/TelephonyProvider.java     | 192 ++++++++-
 3 files changed, 633 insertions(+), 13 deletions(-)
 create mode 100644 src/com/android/providers/telephony/CdmaCallOptionProvider.java

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 2a1bdf3..e0bbcc2 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -87,5 +87,9 @@
                   android:singleUser="true"
                   android:multiprocess="false"
                   android:writePermission="android.permission.MODIFY_PHONE_STATE" />
+
+        <provider android:name="CdmaCallOptionProvider"
+                  android:authorities="cdma"
+                  android:exported="true" />
     </application>
 </manifest>
diff --git a/src/com/android/providers/telephony/CdmaCallOptionProvider.java b/src/com/android/providers/telephony/CdmaCallOptionProvider.java
new file mode 100644
index 0000000..fd42b2a
--- /dev/null
+++ b/src/com/android/providers/telephony/CdmaCallOptionProvider.java
@@ -0,0 +1,450 @@
+/*
+** Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+** Not a Contribution.
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package com.android.providers.telephony;
+
+import android.content.ContentProvider;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.UriMatcher;
+import android.content.res.Resources;
+import android.content.res.XmlResourceParser;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.os.Environment;
+import android.provider.Telephony;
+import android.util.Config;
+import android.util.Log;
+import android.util.Xml;
+
+import com.android.internal.util.XmlUtils;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+
+public class CdmaCallOptionProvider extends ContentProvider {
+
+    private static final String DATABASE_NAME = "cdmacalloption.db";
+
+    private static final int DATABASE_VERSION = 1;
+
+    // call option type: call forwarding, cancel all, call waiting
+    private static final int CFUNCONDITIONAL = 0;
+    private static final int CFBUSY          = 1;
+    private static final int CFNOREPLY       = 2;
+    private static final int CFNOREACHABLE   = 3;
+    private static final int CFDEACTIVATEALL = 4;
+    private static final int CALLWAITING = 6;
+
+    // call option state: activate, deactivate
+    private static final int ACTIVATE = 1;
+    private static final int DEACTIVATE = 2;
+
+    private static final int URL_TELEPHONY = 1;
+    private static final int URL_CFU = 2;
+    private static final int URL_CFB = 3;
+    private static final int URL_CFNRY = 4;
+    private static final int URL_CFNRC = 5;
+    private static final int URL_CFDA = 6;
+    private static final int URL_CW = 7;
+
+    private static final String TAG = "CdmaCallOptionProvider";
+    private static final String CALL_OPTION_TABLE = "calloption";
+    private static final String PARTNER_CDMA_CALL_PATH = "etc/cdma_call_conf.xml";
+    private static final UriMatcher s_urlMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+
+    private SQLiteOpenHelper mOpenHelper;
+
+    static {
+        s_urlMatcher.addURI("cdma", "calloption", URL_TELEPHONY);
+        s_urlMatcher.addURI("cdma", "calloption/cfu", URL_CFU);
+        s_urlMatcher.addURI("cdma", "calloption/cfb", URL_CFB);
+        s_urlMatcher.addURI("cdma", "calloption/cfnry", URL_CFNRY);
+        s_urlMatcher.addURI("cdma", "calloption/cfnrc", URL_CFNRC);
+        s_urlMatcher.addURI("cdma", "calloption/cfda", URL_CFDA);
+        s_urlMatcher.addURI("cdma", "calloption/cw", URL_CW);
+    }
+
+    private static class DatabaseHelper extends SQLiteOpenHelper {
+        // Context to access resources with
+        private Context mContext;
+
+        /**
+         * DatabaseHelper helper class for loading data profiles into a database.
+         *
+         * @param parser the system-default parser for apns.xml
+         * @param confidential an optional parser for confidential APNS (stored separately)
+         */
+        public DatabaseHelper(Context context) {
+            super(context, DATABASE_NAME, null, DATABASE_VERSION);
+            mContext = context;
+        }
+
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            // Set up the database schema
+            db.execSQL("CREATE TABLE " + CALL_OPTION_TABLE +
+                "(_id INTEGER PRIMARY KEY," +
+                    "name TEXT," +
+                    "numeric TEXT," +
+                    "mcc TEXT," +
+                    "mnc TEXT," +
+                    "number TEXT," +
+                    "type INTEGER," +
+                    "category INTEGER," +
+                    "state INTEGER);");
+
+            initDatabase(db);
+        }
+
+        private void initDatabase(SQLiteDatabase db) {
+            // Read cdma call option data (partner-provided)
+            XmlPullParser confparser = null;
+            // Environment.getRootDirectory() is a fancy way of saying ANDROID_ROOT or "/system".
+            File confFile = new File(Environment.getRootDirectory(), PARTNER_CDMA_CALL_PATH);
+            FileReader confreader = null;
+            try {
+                confreader = new FileReader(confFile);
+                confparser = Xml.newPullParser();
+                confparser.setInput(confreader);
+                XmlUtils.beginDocument(confparser, "calloptions");
+                loadProfiles(db, confparser);
+            } catch (FileNotFoundException e) {
+                // It's ok if the file isn't found. It means there isn't a confidential file
+                // Log.e(TAG, "File not found: '" + confFile.getAbsolutePath() + "'");
+            } catch (Exception e) {
+                Log.e(TAG, "Exception while parsing '" + confFile.getAbsolutePath() + "'", e);
+            } finally {
+                try { if (confreader != null) confreader.close(); } catch (IOException e) { }
+            }
+        }
+
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            db.execSQL("DROP TABLE IF EXISTS " + CALL_OPTION_TABLE);
+            onCreate(db);
+        }
+
+        /**
+         * Gets the next row of data profile values.
+         *
+         * @param parser the parser
+         * @return the row or null if it's not an call option
+         */
+        private ContentValues getRow(XmlPullParser parser) {
+            // get the profile type from the XML file tags
+            String prof_type = parser.getName();
+            if (!"option".equals(prof_type)) {
+                return null;
+            }
+            ContentValues map = new ContentValues();
+
+            String mcc = parser.getAttributeValue(null, "mcc");
+            String mnc = parser.getAttributeValue(null, "mnc");
+            String numeric = mcc + mnc;
+
+            map.put(Telephony.CdmaCallOptions.NUMERIC,numeric);
+            map.put(Telephony.CdmaCallOptions.MCC, mcc);
+            map.put(Telephony.CdmaCallOptions.MNC, mnc);
+            map.put(Telephony.CdmaCallOptions.NAME, parser.getAttributeValue(null, "carrier"));
+            map.put(Telephony.CdmaCallOptions.NUMBER, parser.getAttributeValue(null, "number"));
+
+            // do not add NULL to the map so that insert() will set the default value
+            String category = parser.getAttributeValue(null, "category");
+            if (category != null) {
+                map.put(Telephony.CdmaCallOptions.CATEGORY, Integer.parseInt(category));
+            }
+            String state = parser.getAttributeValue(null, "state");
+            if (state != null) {
+                map.put(Telephony.CdmaCallOptions.STATE, Integer.parseInt(state));
+            }
+            String type = parser.getAttributeValue(null, "type");
+            if (type != null) {
+                map.put(Telephony.CdmaCallOptions.TYPE, Integer.parseInt(type));
+            }
+
+            return map;
+        }
+
+        /*
+         * Loads data profiles from xml file into the database
+         *
+         * @param db the sqlite database to write to
+         * @param parser the xml parser
+         *
+         */
+        private void loadProfiles(SQLiteDatabase db, XmlPullParser parser) {
+            if (parser != null) {
+                try {
+                    while (true) {
+                        XmlUtils.nextElement(parser);
+                        ContentValues row = getRow(parser);
+                        if (row != null) {
+                            insertAddingDefaults(db, CALL_OPTION_TABLE, row);
+                        } else {
+                            break;  // do we really want to skip the rest of the file?
+                        }
+                    }
+                } catch (XmlPullParserException e)  {
+                    Log.e(TAG, "Got execption while getting perferred time zone.", e);
+                } catch (IOException e) {
+                    Log.e(TAG, "Got execption while getting perferred time zone.", e);
+                }
+            }
+        }
+
+        private void insertAddingDefaults(SQLiteDatabase db, String table, ContentValues row) {
+            // Initialize defaults if any
+            if (row.containsKey(Telephony.CdmaCallOptions.CATEGORY) == false) {
+                row.put(Telephony.CdmaCallOptions.CATEGORY, -1);
+            }
+            if (row.containsKey(Telephony.CdmaCallOptions.STATE) == false) {
+                row.put(Telephony.CdmaCallOptions.STATE, -1);
+            }
+            db.insert(CALL_OPTION_TABLE, null, row);
+        }
+    }
+
+    @Override
+    public boolean onCreate() {
+        mOpenHelper = new DatabaseHelper(getContext());
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+        return true;
+    }
+
+
+
+    @Override
+    public Cursor query(Uri url, String[] projectionIn, String selection,
+            String[] selectionArgs, String sort) {
+        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+        qb.setTables("calloption");
+
+        int match = s_urlMatcher.match(url);
+        switch (match) {
+            // do nothing
+            case URL_TELEPHONY: {
+                break;
+            }
+
+            case URL_CFU: {
+                qb.appendWhere("type = " + CFUNCONDITIONAL);
+                break;
+            }
+
+            case URL_CFB: {
+                qb.appendWhere("type = " + CFBUSY);
+                break;
+            }
+
+            case URL_CFNRY: {
+                qb.appendWhere("type = " + CFNOREPLY);
+                break;
+            }
+
+            case URL_CFNRC: {
+                qb.appendWhere("type = " + CFNOREACHABLE);
+                break;
+            }
+
+            case URL_CFDA: {
+                qb.appendWhere("type = " + CFDEACTIVATEALL);
+                break;
+            }
+
+            case URL_CW: {
+                qb.appendWhere("type = " + CALLWAITING);
+                break;
+            }
+
+            default: {
+                return null;
+            }
+        }
+
+        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
+        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs, null, null, sort);
+        ret.setNotificationUri(getContext().getContentResolver(), url);
+        return ret;
+    }
+
+
+    @Override
+    public Uri insert(Uri url, ContentValues initialValues)
+    {
+        Uri result = null;
+
+        //checkPermission();
+
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+        int match = s_urlMatcher.match(url);
+        boolean notify = false;
+        ContentValues values = new ContentValues(initialValues);
+        switch (match)
+        {
+            case URL_TELEPHONY:
+            {
+                // TODO Review this. This code should probably not bet here.
+                // It is valid for the database to return a null string.
+                if (values.containsKey(Telephony.CdmaCallOptions.NAME) == false) {
+                    values.put(Telephony.CdmaCallOptions.NAME, "");
+                }
+                if (values.containsKey(Telephony.CdmaCallOptions.NUMBER) == false) {
+                    values.put(Telephony.CdmaCallOptions.NUMBER, "");
+                }
+                if (values.containsKey(Telephony.CdmaCallOptions.TYPE) == false) {
+                    values.put(Telephony.CdmaCallOptions.TYPE, -1);
+                }
+                break;
+            }
+            case URL_CFU: {
+                values.put(Telephony.CdmaCallOptions.TYPE, CFUNCONDITIONAL);
+                break;
+            }
+            case URL_CFB: {
+                values.put(Telephony.CdmaCallOptions.TYPE, CFBUSY);
+                break;
+            }
+            case URL_CFNRY: {
+                values.put(Telephony.CdmaCallOptions.TYPE, CFNOREPLY);
+                break;
+            }
+            case URL_CFNRC: {
+                values.put(Telephony.CdmaCallOptions.TYPE, CFNOREACHABLE);
+                break;
+            }
+            case URL_CFDA: {
+                values.put(Telephony.CdmaCallOptions.TYPE, CFDEACTIVATEALL);
+                values.put(Telephony.CdmaCallOptions.STATE, DEACTIVATE);
+                values.put(Telephony.CdmaCallOptions.CATEGORY, -1);
+                break;
+            }
+            case URL_CW: {
+                values.put(Telephony.CdmaCallOptions.TYPE, CALLWAITING);
+                values.put(Telephony.CdmaCallOptions.CATEGORY, -1);
+                break;
+            }
+            default: {
+                throw new UnsupportedOperationException("Cannot delete that URL: " + url);
+            }
+        }
+        long rowID = db.insert(CALL_OPTION_TABLE, null, values);
+        if (rowID > 0) {
+            result = ContentUris.withAppendedId(Telephony.CdmaCallOptions.CONTENT_URI, rowID);
+            notify = true;
+        }
+
+        if (Config.LOGD) Log.d(TAG, "inserted " + values.toString() + " rowID = " + rowID);
+
+        if (notify) {
+            getContext().getContentResolver().notifyChange(
+                    Telephony.CdmaCallOptions.CONTENT_URI, null);
+        }
+
+        return result;
+    }
+
+    @Override
+    public int delete(Uri url, String where, String[] whereArgs)
+    {
+        int count;
+
+        /**
+         * we need to delete all the ssfc with the same mnc/mcc when a new card is inserted
+         */
+        //checkPermission();
+
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+        int match = s_urlMatcher.match(url);
+        switch (match)
+        {
+            case URL_TELEPHONY:
+            {
+                count = db.delete(CALL_OPTION_TABLE, where, whereArgs);
+                break;
+            }
+
+            default: {
+                throw new UnsupportedOperationException("Cannot delete that URL: " + url);
+            }
+        }
+
+        getContext().getContentResolver().notifyChange(
+                Telephony.CdmaCallOptions.CONTENT_URI, null);
+
+        return count;
+    }
+
+    @Override
+    public int update(Uri url, ContentValues values, String where, String[] whereArgs)
+    {
+        int count = 0;
+
+        checkPermission();
+
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+        int match = s_urlMatcher.match(url);
+        switch (match)
+        {
+            case URL_TELEPHONY:
+            {
+                count = db.update(CALL_OPTION_TABLE, values, where, whereArgs);
+                break;
+            }
+            default: {
+                throw new UnsupportedOperationException("Cannot update that URL: " + url);
+            }
+        }
+
+        if (count > 0) {
+            getContext().getContentResolver().notifyChange(
+                    Telephony.CdmaCallOptions.CONTENT_URI, null);
+        }
+
+        return count;
+    }
+
+    @Override
+    public String getType(Uri url)
+    {
+        switch (s_urlMatcher.match(url)) {
+        case URL_TELEPHONY:
+            return "vnd.android.cursor.dir/telephony-calloption";
+
+        default:
+            throw new IllegalArgumentException("Unknown URL " + url);
+        }
+    }
+
+    private void checkPermission() {
+        // Check the permissions
+        getContext().enforceCallingOrSelfPermission("android.permission.WRITE_CDMA_CALL_SETTINGS",
+                "No permission to write Cdma call settings");
+    }
+}
diff --git a/src/com/android/providers/telephony/TelephonyProvider.java b/src/com/android/providers/telephony/TelephonyProvider.java
index 8669cdf..354a009 100644
--- a/src/com/android/providers/telephony/TelephonyProvider.java
+++ b/src/com/android/providers/telephony/TelephonyProvider.java
@@ -105,6 +105,7 @@ public class TelephonyProvider extends ContentProvider
     private static final String OEM_APNS_PATH = "telephony/apns-conf.xml";
     private static final String OTA_UPDATED_APNS_PATH = "misc/apns-conf.xml";
     private static final String OLD_APNS_PATH = "etc/old-apns-conf.xml";
+    private static final String REGIONAL_APNS_PATH = "etc/regional-apns-conf.xml";
 
     private static final String READ_ONLY = "read_only";
     private static final String LOCALIZED_NAME = "localized_name";
@@ -270,7 +271,8 @@ public class TelephonyProvider extends ContentProvider
                     + SubscriptionManager.CB_ALERT_SPEECH + " INTEGER DEFAULT " + speechEnabled + ","
                     + SubscriptionManager.CB_ETWS_TEST_ALERT + " INTEGER DEFAULT 0,"
                     + SubscriptionManager.CB_CHANNEL_50_ALERT + " INTEGER DEFAULT 1,"
-                    + SubscriptionManager.CB_CMAS_TEST_ALERT + " INTEGER DEFAULT 0,"
+                    + SubscriptionManager.CB_CHANNEL_60_ALERT + " INTEGER DEFAULT 1,"
+                    + SubscriptionManager.CB_CMAS_TEST_ALERT + " INTEGER DEFAULT 1,"
                     + SubscriptionManager.CB_OPT_OUT_DIALOG + " INTEGER DEFAULT 1"
                     + ");");
             if (DBG) log("dbh.createSimInfoTable:-");
@@ -379,20 +381,41 @@ public class TelephonyProvider extends ContentProvider
             FileReader confreader = null;
             if (DBG) log("confFile = " + confFile);
             try {
+                // Read external APNS data (partner-provided)
                 confreader = new FileReader(confFile);
-                confparser = Xml.newPullParser();
-                confparser.setInput(confreader);
-                XmlUtils.beginDocument(confparser, "apns");
+                confparser = getXmlParser(confreader);
+
+                if (confparser != null) {
+                    // Sanity check. Force internal version and confidential versions to agree
+                    int confversion = Integer.parseInt(confparser.
+                            getAttributeValue(null, "version"));
+                    if (publicversion != confversion) {
+                        log("initDatabase: throwing exception due to version mismatch");
+                        throw new IllegalStateException("Internal APNS file version doesn't match "
+                                + confFile.getAbsolutePath());
+                    }
 
-                // Sanity check. Force internal version and confidential versions to agree
-                int confversion = Integer.parseInt(confparser.getAttributeValue(null, "version"));
-                if (publicversion != confversion) {
-                    log("initDatabase: throwing exception due to version mismatch");
-                    throw new IllegalStateException("Internal APNS file version doesn't match "
-                            + confFile.getAbsolutePath());
+                    loadApns(db, confparser);
+
+                    try {
+                        if (confreader != null) {
+                            confreader.close();
+                            confreader = null;
+                        }
+                        confparser = null;
+                    } catch (IOException e) { }
                 }
 
-                loadApns(db, confparser);
+                confFile = new File(Environment.getRootDirectory(), REGIONAL_APNS_PATH);
+                if (confFile.exists()) {
+                    confreader = new FileReader(confFile);
+                    confparser = getXmlParser(confreader);
+                    if (confparser != null) {
+                        loadRegionalApns(db, confparser);
+                    }
+                } else {
+                    if (DBG) log("Regional apns file not found");
+                }
             } catch (FileNotFoundException e) {
                 // It's ok if the file isn't found. It means there isn't a confidential file
                 // Log.e(TAG, "File not found: '" + confFile.getAbsolutePath() + "'");
@@ -431,8 +454,22 @@ public class TelephonyProvider extends ContentProvider
                     }
                 }
             }
+
             if (VDBG) log("dbh.initDatabase:- db=" + db);
+        }
+
+        private XmlPullParser getXmlParser(FileReader confreader) {
+            XmlPullParser confparser = null;
+            try {
+                confparser = Xml.newPullParser();
+                confparser.setInput(confreader);
+                XmlUtils.beginDocument(confparser, "apns");
 
+            } catch (Exception e) {
+                loge("Exception while parsing apns xml file" + e);
+            }
+
+            return confparser;
         }
 
         private File getNewerFile(File sysApnFile, File altApnFile) {
@@ -731,7 +768,9 @@ public class TelephonyProvider extends ContentProvider
                     db.execSQL("ALTER TABLE " + SIMINFO_TABLE + " ADD COLUMN "
                             + SubscriptionManager.CB_CHANNEL_50_ALERT + " INTEGER DEFAULT 1;");
                     db.execSQL("ALTER TABLE " + SIMINFO_TABLE + " ADD COLUMN "
-                            + SubscriptionManager.CB_CMAS_TEST_ALERT + " INTEGER DEFAULT 0;");
+                            + SubscriptionManager.CB_CHANNEL_60_ALERT + " INTEGER DEFAULT 1;");
+                    db.execSQL("ALTER TABLE " + SIMINFO_TABLE + " ADD COLUMN "
+                            + SubscriptionManager.CB_CMAS_TEST_ALERT + " INTEGER DEFAULT 1;");
                     db.execSQL("ALTER TABLE " + SIMINFO_TABLE + " ADD COLUMN "
                             + SubscriptionManager.CB_OPT_OUT_DIALOG + " INTEGER DEFAULT 1;");
                 } catch (SQLiteException e) {
@@ -1255,6 +1294,132 @@ public class TelephonyProvider extends ContentProvider
             }
         }
 
+        /*
+         * Read apns from regional xml file one by one and update them to database
+         * - Replace apn if a match is found from telephony database,
+         * - Add apn if there is no match found from database
+         * @param db the sqlite database to write to
+         * @param parser the xml parser
+         *
+         */
+        private void loadRegionalApns(SQLiteDatabase db, XmlPullParser parser) {
+            if (DBG) log("Reading regional apns file");
+
+            try {
+                String[] apnParams = {Telephony.Carriers.NUMERIC,
+                        Telephony.Carriers.APN,
+                        Telephony.Carriers.NAME,
+                        Telephony.Carriers.TYPE};
+
+                db.beginTransaction();
+                XmlUtils.nextElement(parser);
+                while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
+                    boolean apnModified = false;
+                    ContentValues row = getRow(parser);
+                    if (row == null) {
+                        throw new XmlPullParserException("Expected 'apn' tag", parser, null);
+                    }
+                    row = setDefaultValue(row);
+
+                    String apnOperation = parser.getAttributeValue(null, "operation");
+                    if (DBG) log("loadRegionalApns: operation on apn: " + apnOperation);
+
+                    /* Construct sqlite query with numeric and apn of xml entry and
+                     * run it on telephony db.
+                     * If a unique match is found, replace it with the apn from xml file.
+                     * Else if multiple apn entries are found with this query,
+                     * re-execute query by adding name, type parameters as well.
+                     * If multiple apn entries are still found with all of these fields, just
+                     * add apn to db.
+                     */
+                    String selection = apnParams[0] + "=" + row.getAsString(apnParams[0]);
+                    for (int i = 0; i < apnParams.length-1; i++) {
+                        selection += " AND " + apnParams[i+1] + "=?";
+                        if (DBG) log("loadRegionalApns: selection: " + selection);
+
+                        //Create a selectionArgs array with values to be passed to sqlite query
+                        String selectionArgs[] = new String[i+1];
+                        for (int j = 0; j <= i; j++) {
+                            selectionArgs[j] = (row.getAsString(apnParams[j+1])).trim();
+                            if (DBG) log("loadRegionalApns: selectionArgs: " + selectionArgs[j]);
+                        }
+
+                        int result = formatApnsInDB(db, row, selection, selectionArgs,
+                                apnOperation);
+                        if (result <= 1) {
+                            apnModified = true;
+                            break;
+                        }
+                     }
+
+                     if (!apnModified && (apnOperation != null &&
+                             !apnOperation.equalsIgnoreCase("delete"))) {
+                         if (DBG) log("loadRegionalApns: Multiple apns found" +
+                                 " in Telephony Database." +
+                                 " Adding regional apn as a new entry");
+                         db.insertWithOnConflict(CARRIERS_TABLE, null, row,
+                                 SQLiteDatabase.CONFLICT_ABORT);
+                     }
+                     XmlUtils.nextElement(parser);
+                }
+                db.setTransactionSuccessful();
+            } catch (XmlPullParserException e) {
+                loge("Got XmlPullParserException while loading apns." + e);
+            } catch (IOException e) {
+                loge("Got IOException while loading apns." + e);
+            } catch (SQLException e) {
+                loge("Got SQLException while loading apns." + e);
+            } finally {
+                db.endTransaction();
+            }
+        }
+
+        private int formatApnsInDB(SQLiteDatabase db, ContentValues row,
+                String selection, String[] selectionArgs, String operation) {
+            int apnCount = 0;
+            String apn = selectionArgs[0];
+
+            try {
+                Cursor cursor = db.query(CARRIERS_TABLE, null, selection,
+                        selectionArgs, null, null, null);
+                if (cursor != null) {
+                    apnCount = cursor.getCount();
+                    if (VDBG) log("apn count: " + apnCount);
+                    if (apnCount > 1) {
+                        if (DBG) log("Multiple apns found in db with same values");
+                    } else if (apnCount == 1) {
+                        if (operation != null) {
+                            if (operation.equalsIgnoreCase("delete")) {
+                                if (DBG) log("Deleting apn in db: " + apn);
+                                db.delete(CARRIERS_TABLE, selection, selectionArgs);
+                            } else if (operation.equalsIgnoreCase("add")) {
+                                if (DBG) log("Adding regional apn to db: " + apn);
+                                db.insertWithOnConflict(CARRIERS_TABLE, null, row,
+                                        SQLiteDatabase.CONFLICT_REPLACE);
+                            }
+                        } else {
+                            if (DBG) log("Replacing apn in db with regional apn: " + apn);
+                            db.delete(CARRIERS_TABLE, selection, selectionArgs);
+                            db.insertWithOnConflict(CARRIERS_TABLE, null, row,
+                                    SQLiteDatabase.CONFLICT_ABORT);
+                        }
+                    } else {
+                        if (!(operation != null &&
+                                operation.equalsIgnoreCase("delete"))) {
+                            if (DBG) log("Adding regional apn to db: " + apn);
+                            db.insertWithOnConflict(CARRIERS_TABLE, null, row,
+                                    SQLiteDatabase.CONFLICT_REPLACE);
+                        }
+                    }
+                    cursor.close();
+                }
+            } catch (SQLException e) {
+                loge("Got SQLException while loading apns." + e);
+            }
+
+            return apnCount;
+        }
+
         static public ContentValues setDefaultValue(ContentValues values) {
             if (!values.containsKey(Telephony.Carriers.SUBSCRIPTION_ID)) {
                 int subId = SubscriptionManager.getDefaultSubId();
@@ -1804,7 +1969,8 @@ public class TelephonyProvider extends ContentProvider
                     return null;
                 }
                 if (DBG) log("subIdString = " + subIdString + " subId = " + subId);
-                qb.appendWhere("numeric = '" + mTelephonyManager.getSimOperator(subId)+"'");
+                qb.appendWhere("numeric = '" +
+                        mTelephonyManager.getIccOperatorNumericForData(subId)+"'");
                 // FIXME alter the selection to pass subId
                 // selection = selection + "and subId = "
             }
-- 
2.7.4

