From c823979901d393e96ebbbafe30f57ff4a659d7c9 Mon Sep 17 00:00:00 2001
From: Sultanxda <sultanxda@gmail.com>
Date: Thu, 28 Jul 2016 13:47:46 -0700
Subject: [PATCH] Squashed commit of the following:

commit 396b4c2c2804e75e2eb556dade5c8904f219fbb9
Author: Gurpreet Ghai <gghai@codeaurora.org>
Date:   Mon Apr 18 19:05:28 2016 +0530

    BT: Set persiste Bluetooth State during enable timeout case

    Use case: When enable timeout occurs during S&S testing and
    Bluetooth state is moved from Turning On to Off.

    Steps: Changes related to enable timeout case, to test the
    changes, S&S testing can be done.

    Failure: Changes done to handle Bluetooth enable timeout
    case when Bluetooth state changes from Turning On to Off.

    Root cause: Setting Bluetooth Persist state to handle the
    enable timeout case so that Bluetooth doesnot self enable
    after enable timeout case is handled.

    Fix: Setting the Bluetooth Persist State to Off when enable
    timeout occurs.

    Change-Id: I17b3b05020eb7469666e6d8c88c86df7764b4024
    CRs-Fixed: 1006444

commit 34040d04c9c0d521b9109eb24d42f079989381dd
Author: Wileen Chiu <wileenc@codeaurora.org>
Date:   Thu Mar 17 18:11:06 2016 -0700

    Add absent sim info to locked screen text

    - For a multisim device, when only one sim is inserted
     that is pin locked, the carrier text only shows
    'SIM CARD IS LOCKED - NO SERVICE' even though the
    voice registration state for one of the phones is 12,
    where emergency calls are allowed
    - This occurs when the state above is reported for the
    slot where a sim card is not inserted. We only check for
    active subscriptions when creating the display text
    - Add a check for when only one sim card is inserted. If
    the voice registration state is out of service for both
    slots, with at least one as 12 (emergency allowed)
    show 'Emergency calls only' instead of 'No service'

    Change-Id: Ib58b6b7431d7b29c770287037cbf07c8df101ae3
    CRs-Fixed: 985955

commit 528b0ddbbe2cd0722d81bd429b2ef43d1fc6f303
Author: Luke Zhang <lukez@codeaurora.org>
Date:   Wed Apr 6 16:20:33 2016 -0700

    Encapsulate the unbindService with try catch block

    BT got stuck in mContext.unbindService when it tried to recover
    from error. The best way to fix it is to encapsulate the
    unbindService with try catch block

    CRs_fixed: 996389

    Change-Id: I51469c312537b31317481096b0f9822e4a611576

commit f689b2e13359d5d943d8729928d359d23d212e02
Author: Ayan Ghosh <abghosh@codeaurora.org>
Date:   Tue Mar 8 19:11:18 2016 +0530

    Bluetooth: Access mediaplayerlist in synchronized way

    Access mediaplayerlist in synchronized way to make sure no transient
    update is tried to be worked upon in multithreaded environment.

    Change-Id: I0e7810ac89e0ddc19d57b32c679450aa7cb87273
    CRs-Fixed: 979840

commit 169748b742043e06b29b9185688d653b7e8f29c3
Author: Manoj Kumar AVM <manojavm@codeaurora.org>
Date:   Mon Jan 18 21:46:16 2016 -0800

    WifiDisplayController: Fix p2p disconnect before rtsp teardown completes

    Disconnect p2p only after onDisplayDisconnected is received which serves
    as a notification from native layers of WFD that RTSP message sequence
    as part of teardown sequence is completed

    Change-Id: I3f678a76d172725d904013476226810faecfbd83

commit a8731119e0236f2efef76d7c195bf2d36b819105
Author: Nalla Kartheek <karthe@codeaurora.org>
Date:   Wed Jan 6 12:54:49 2016 +0530

    Wifi: Make maximum selective channel scans and interval configurable

    The change makes max initial scans on selective channels
    and initial saved channel scan interval configurable.

    Change-Id: I61a9c0b203dca879c1420886d06659a277a7ed99
    CRs-Fixed: 909098

commit 47ea7c7916fb8bd5e9441e339dbb65d2b36537c6
Author: Kevin Tang <zhikait@codeaurora.org>
Date:   Wed Jan 13 13:14:03 2016 -0800

    combo bug when location reported by providers do not come with extras

    LocationManagerService tries to create an extra bundle and stick it
    into the location object, but it is not doing it correctly. As a
    result, combo drops report.

    Change-Id: I6f5886dd7f14819ecc7a4ed96c867a0ec486faf7
    CRs-Fixed: 962746

commit 914b672445bc6abc6d045b2fe208216621614da3
Author: Richard LIU <richardl@codeaurora.org>
Date:   Mon Nov 23 16:44:35 2015 +0800

    Ignore IMS type APN when notify data connection

    Do not add IMS type APN in mConnectedApns.

    Change-Id: I339a2c411f94572c00e9df48deb38aab1046e581

commit 6fcfa2e8af2518c36188997de39201b735b1586b
Author: Sandeep Kunta <skunta@codeaurora.org>
Date:   Thu Feb 4 11:43:33 2016 +0530

    Remove TONE_SUPERVISORY_CH

    Remove TONE_SUPERVISORY_CH, since its no longer used.

    Change-Id: Idd1c5e4cab878362975cb3fb38332e39276a2a6b
    CRs-Fixed: 967597

commit 4d75d9e6750cb4240ec69da077abadee13a0d7a2
Author: Muhammed Siju <msiju@codeaurora.org>
Date:   Mon Jan 4 11:36:55 2016 +0530

    MSIM: Restrict data activity change to listeners with matching subId

    Currently data activity change callback is invoked on all listeners
    irresepctive of subId. This causes wrong data activity value to be
    updated from other sub. To fix this add subId match before invoking
    callbacks on listeners.

    Change-Id: If218ea3ead2b837d9c2d1cac4d353c1d35c5babe
    CRs-Fixed: 957838

commit 52f0f91c7c2a0a9bdcaa2c89c26811ad96d034c4
Author: Dheeraj Shetty <dshetty@codeaurora.org>
Date:   Wed Apr 13 19:10:14 2016 -0700

    Add config to show HD icon on EVS codec.

    Add config to show HD icon when audio codec is EVS_WB, EVS_SWB
    and EVS_FB.
    Default value is false.

    Change-Id: I6c6b9fc413ba1298522d8c661b50f458a71a2aa7
    CRs-fixed: 986961

Change-Id: Ib06538f7e35fb43f65c406fdc3bcf5a6ead98223
---
 core/java/android/bluetooth/BluetoothAdapter.java  |   4 +-
 core/res/res/values/config.xml                     |   6 +
 core/res/res/values/symbols.xml                    |   2 +
 media/java/android/media/ToneGenerator.java        |   6 -
 .../src/com/android/keyguard/CarrierText.java      |  19 +++
 .../android/keyguard/KeyguardUpdateMonitor.java    |  30 +++++
 .../android/server/BluetoothManagerService.java    |  17 ++-
 .../com/android/server/LocationManagerService.java |   9 +-
 .../java/com/android/server/TelephonyRegistry.java |   6 +-
 .../com/android/server/audio/AudioService.java     | 140 +++++++++++----------
 .../server/display/WifiDisplayController.java      |  97 +++++++++++---
 .../android/telephony/CarrierConfigManager.java    |   8 ++
 12 files changed, 245 insertions(+), 99 deletions(-)

diff --git a/core/java/android/bluetooth/BluetoothAdapter.java b/core/java/android/bluetooth/BluetoothAdapter.java
index f924bc1..71183d9 100644
--- a/core/java/android/bluetooth/BluetoothAdapter.java
+++ b/core/java/android/bluetooth/BluetoothAdapter.java
@@ -2067,13 +2067,14 @@ public final class BluetoothAdapter {
             }
 
             public void onBluetoothServiceDown() {
-                if (VDBG) Log.d(TAG, "onBluetoothServiceDown: " + mService);
+                Log.d(TAG, "onBluetoothServiceDown: " + mService);
                 synchronized (mManagerCallback) {
                     mService = null;
                     if (mLeScanClients != null) mLeScanClients.clear();
                     if (sBluetoothLeAdvertiser != null) sBluetoothLeAdvertiser.cleanup();
                     if (sBluetoothLeScanner != null) sBluetoothLeScanner.cleanup();
                     synchronized (mProxyServiceStateCallbacks) {
+                        Log.d(TAG, "onBluetoothServiceDown: Sending callbacks to " + mProxyServiceStateCallbacks.size() + " clients");
                         for (IBluetoothManagerCallback cb : mProxyServiceStateCallbacks ){
                             try {
                                 if (cb != null) {
@@ -2085,6 +2086,7 @@ public final class BluetoothAdapter {
                         }
                     }
                 }
+                Log.d(TAG, "onBluetoothServiceDown: Finished sending callbacks to registered clients");
             }
 
             public void onBrEdrDown() {
diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index 882523e..79bf24e 100644
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -504,6 +504,12 @@
     <!-- Integer indicating RSSI boost given to current network -->
     <integer translatable="false" name="config_wifi_framework_current_network_boost">25</integer>
 
+    <!-- Integer indicating the number of selective channel scan when Wifi turn on -->
+    <integer translatable="false" name="config_max_initial_scans_on_selective_channels">2</integer>
+
+    <!-- Integer indicating the interval for selective channel scan when Wifi turn on -->
+    <integer translatable="false" name="config_initial_saved_channel_scan_interval">2000</integer>
+
     <!-- Integer indicating how to handle beacons with uninitialized RSSI value of 0 -->
     <integer translatable="false" name="config_wifi_framework_scan_result_rssi_level_patchup_value">-85</integer>
 
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 92b3b2d..0989e20 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -363,6 +363,8 @@
   <java-symbol type="integer" name="config_wifi_framework_max_auth_errors_to_blacklist" />
   <java-symbol type="integer" name="config_wifi_framework_network_black_list_min_time_milli" />
   <java-symbol type="integer" name="config_wifi_framework_current_network_boost" />
+  <java-symbol type="integer" name="config_max_initial_scans_on_selective_channels" />
+  <java-symbol type="integer" name="config_initial_saved_channel_scan_interval"/>
   <java-symbol type="bool" name="config_send_sms1x_on_voice_call" />
   <java-symbol type="integer" name="config_bluetooth_max_advertisers" />
   <java-symbol type="integer" name="config_bluetooth_max_scan_filters" />
diff --git a/media/java/android/media/ToneGenerator.java b/media/java/android/media/ToneGenerator.java
index 08c49e7..056244a 100644
--- a/media/java/android/media/ToneGenerator.java
+++ b/media/java/android/media/ToneGenerator.java
@@ -729,12 +729,6 @@ public class ToneGenerator
      */
     public static final int TONE_CDMA_SIGNAL_OFF = 98;
     /**
-     * SUPERVISORY_CH - 440Hz
-     *
-     * @hide #ToneGenerator(int, int)
-     */
-    public static final int TONE_SUPERVISORY_CH = 100;
-    /**
      * HOLD_RECALL - 440Hz
      *
      * @hide #ToneGenerator(int, int)
diff --git a/packages/Keyguard/src/com/android/keyguard/CarrierText.java b/packages/Keyguard/src/com/android/keyguard/CarrierText.java
index 8dd56fa..f21ce7f 100644
--- a/packages/Keyguard/src/com/android/keyguard/CarrierText.java
+++ b/packages/Keyguard/src/com/android/keyguard/CarrierText.java
@@ -188,6 +188,25 @@ public class CarrierText extends TextView {
                 }
             }
         }
+        /*
+         * In the case where there is only one sim inserted in a multisim device, if
+         * the voice registration service state is reported as 12 (no service with emergency)
+         * for at least one of the sim concatenate the sim state with Emergency calls only"
+         */
+        if (N < TelephonyManager.getDefault().getPhoneCount() &&
+                 mKeyguardUpdateMonitor.isEmergencyOnly()) {
+            int presentSubId = mKeyguardUpdateMonitor.getPresentSubId();
+
+            if (DEBUG) {
+                Log.d(TAG, " Present sim - sub id: " + presentSubId);
+            }
+            if (presentSubId != -1) {
+                CharSequence emergencyOnlyText =
+                        getContext().getText(com.android.internal.R.string.emergency_calls_only);
+                displayText = getCarrierTextForSimState(
+                        mKeyguardUpdateMonitor.getSimState(presentSubId), emergencyOnlyText);
+            }
+        }
         if (allSimsMissing) {
             if (N != 0) {
                 // Shows "No SIM card | Emergency calls only" on devices that are voice-capable.
diff --git a/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java b/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
index be8ded3..f608f13 100644
--- a/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
+++ b/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
@@ -383,6 +383,36 @@ public class KeyguardUpdateMonitor implements TrustManager.TrustListener {
         return mSubscriptionInfo;
     }
 
+    public boolean isEmergencyOnly() {
+        boolean isEmerg = false;
+        ServiceState state;
+        for (int slotId = 0; slotId < TelephonyManager.getDefault().getPhoneCount(); slotId++) {
+            state = null;
+            int[] subId = mSubscriptionManager.getSubId(slotId);
+            if (subId != null && subId.length > 0) {
+                state = mServiceStates.get(subId[0]);
+            }
+            if (state != null) {
+                if (state.getVoiceRegState() == ServiceState.STATE_IN_SERVICE)
+                    return false;
+                else if (state.isEmergencyOnly()) {
+                    isEmerg = true;
+                }
+            }
+        }
+        return isEmerg;
+    }
+
+    public int getPresentSubId() {
+        for (int slotId = 0; slotId < TelephonyManager.getDefault().getPhoneCount(); slotId++) {
+            int[] subId = mSubscriptionManager.getSubId(slotId);
+            if (subId != null && subId.length > 0 && getSimState(subId[0]) != State.ABSENT) {
+                return subId[0];
+            }
+        }
+        return -1;
+    }
+
     @Override
     public void onTrustManagedChanged(boolean managed, int userId) {
         mUserTrustIsManaged.put(userId, managed);
diff --git a/services/core/java/com/android/server/BluetoothManagerService.java b/services/core/java/com/android/server/BluetoothManagerService.java
index 5a76227..dbdffef 100644
--- a/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/services/core/java/com/android/server/BluetoothManagerService.java
@@ -763,6 +763,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                     }  catch (RemoteException e) {
                         Log.e(TAG, "Unable to call onBluetoothServiceUp() on callback #" + i, e);
                     }
+                    Log.d(TAG, "Broadcasted onBluetoothServiceUp() to " + mCallbacks.getBroadcastItem(i));
                 }
             } finally {
                 mCallbacks.finishBroadcast();
@@ -784,6 +785,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                     }  catch (RemoteException e) {
                         Log.e(TAG, "Unable to call onBluetoothServiceDown() on callback #" + i, e);
                     }
+                    Log.d(TAG, "Broadcasted onBluetoothServiceDown() to " + mCallbacks.getBroadcastItem(i));
                 }
             } finally {
                 mCallbacks.finishBroadcast();
@@ -1145,8 +1147,13 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                         recoverBluetoothServiceFromError();
                     }
                     if ((prevState == BluetoothAdapter.STATE_TURNING_ON) &&
-                        (newState == BluetoothAdapter.STATE_BLE_ON) &&
-                        (mBluetooth != null) && mEnable) {
+                            (newState == BluetoothAdapter.STATE_OFF) &&
+                            (mBluetooth != null) && mEnable) {
+                        persistBluetoothSetting(BLUETOOTH_OFF);
+                    }
+                    if ((prevState == BluetoothAdapter.STATE_TURNING_ON) &&
+                            (newState == BluetoothAdapter.STATE_BLE_ON) &&
+                            (mBluetooth != null) && mEnable) {
                         recoverBluetoothServiceFromError();
                     }
                     if (newState == BluetoothAdapter.STATE_ON ||
@@ -1646,7 +1653,11 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             if (mBluetooth != null) {
                 mBluetooth = null;
                 //Unbind
-                mContext.unbindService(mConnection);
+                try {
+                    mContext.unbindService(mConnection);
+                } catch (Exception e) {
+                    Log.e(TAG, "Unable to unbind",e);
+                }
             }
             mBluetoothGatt = null;
         }
diff --git a/services/core/java/com/android/server/LocationManagerService.java b/services/core/java/com/android/server/LocationManagerService.java
index ebe8759..6cd8e10 100644
--- a/services/core/java/com/android/server/LocationManagerService.java
+++ b/services/core/java/com/android/server/LocationManagerService.java
@@ -2418,11 +2418,8 @@ public class LocationManagerService extends ILocationManager.Stub {
 
         Bundle extras = location.getExtras();
         boolean isBeingScreened = false;
-        if (extras == null) {
-            extras = new Bundle();
-        }
 
-        if (!extras.containsKey(mComboNlpReadyMarker)) {
+        if (extras == null || !extras.containsKey(mComboNlpReadyMarker)) {
             // see if Combo Nlp is a passive listener
             ArrayList<UpdateRecord> records =
                 mRecordsByProvider.get(LocationManager.PASSIVE_PROVIDER);
@@ -2431,6 +2428,10 @@ public class LocationManagerService extends ILocationManager.Stub {
                     if (r.mReceiver.mPackageName.equals(mComboNlpPackageName)) {
                         if (!isBeingScreened) {
                             isBeingScreened = true;
+                            if (extras == null) {
+                                location.setExtras(new Bundle());
+                                extras = location.getExtras();
+                            }
                             extras.putBoolean(mComboNlpScreenMarker, true);
                         }
                         // send location to Combo Nlp for screening
diff --git a/services/core/java/com/android/server/TelephonyRegistry.java b/services/core/java/com/android/server/TelephonyRegistry.java
index 5dac953..c7f4d0f 100644
--- a/services/core/java/com/android/server/TelephonyRegistry.java
+++ b/services/core/java/com/android/server/TelephonyRegistry.java
@@ -1019,7 +1019,8 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
             if (validatePhoneId(phoneId)) {
                 mDataActivity[phoneId] = state;
                 for (Record r : mRecords) {
-                    if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_DATA_ACTIVITY)) {
+                    if (r.matchPhoneStateListenerEvent(PhoneStateListener.LISTEN_DATA_ACTIVITY)
+                            && idMatch(r.subId, subId, phoneId)) {
                         try {
                             r.callback.onDataActivity(state);
                         } catch (RemoteException ex) {
@@ -1062,7 +1063,8 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
                 }
                 boolean modified = false;
                 if (state == TelephonyManager.DATA_CONNECTED) {
-                    if (!mConnectedApns[phoneId].contains(apnType)) {
+                    if (!mConnectedApns[phoneId].contains(apnType)
+                            && !apnType.equals(PhoneConstants.APN_TYPE_IMS)) {
                         mConnectedApns[phoneId].add(apnType);
                         if (mDataConnectionState[phoneId] != state) {
                             mDataConnectionState[phoneId] = state;
diff --git a/services/core/java/com/android/server/audio/AudioService.java b/services/core/java/com/android/server/audio/AudioService.java
index ef2ff62..fe3df61 100644
--- a/services/core/java/com/android/server/audio/AudioService.java
+++ b/services/core/java/com/android/server/audio/AudioService.java
@@ -911,59 +911,63 @@ public class AudioService extends IAudioService.Stub {
      * @hide
      */
     public void addMediaPlayerAndUpdateRemoteController (String packageName) {
-        Log.v(TAG, "addMediaPlayerAndUpdateRemoteController: size of existing list: " +
-                mMediaPlayers.size());
-        boolean playerToAdd = true;
-        if (mMediaPlayers.size() > 0) {
-            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
-            while (rccIterator.hasNext()) {
-                final MediaPlayerInfo player = rccIterator.next();
-                if (packageName.equals(player.getPackageName())) {
-                    Log.e(TAG, "Player entry present, no need to add");
-                    playerToAdd = false;
-                    player.setFocus(true);
-                } else {
-                    Log.e(TAG, "Player: " + player.getPackageName()+ "Lost Focus");
-                    player.setFocus(false);
+        synchronized(mMediaPlayers) {
+            Log.v(TAG, "addMediaPlayerAndUpdateRemoteController: size of existing list: " +
+                    mMediaPlayers.size());
+            boolean playerToAdd = true;
+            if (mMediaPlayers.size() > 0) {
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    final MediaPlayerInfo player = rccIterator.next();
+                    if (packageName.equals(player.getPackageName())) {
+                        Log.e(TAG, "Player entry present, no need to add");
+                        playerToAdd = false;
+                        player.setFocus(true);
+                    } else {
+                        Log.e(TAG, "Player: " + player.getPackageName()+ "Lost Focus");
+                        player.setFocus(false);
+                    }
                 }
             }
+            if (playerToAdd) {
+                Log.e(TAG, "Adding Player: " + packageName + " to available player list");
+                mMediaPlayers.add(new MediaPlayerInfo(packageName, true));
+            }
+            Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
+            intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME, packageName);
+            intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE, true);
+            intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, true);
+            sendBroadcastToAll(intent);
+            Log.v(TAG, "updating focussed RCC change to RCD: CallingPackageName:"
+                    + packageName);
         }
-        if (playerToAdd) {
-            Log.e(TAG, "Adding Player: " + packageName + " to available player list");
-            mMediaPlayers.add(new MediaPlayerInfo(packageName, true));
-        }
-        Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
-        intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME, packageName);
-        intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE, true);
-        intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, true);
-        sendBroadcastToAll(intent);
-        Log.v(TAG, "updating focussed RCC change to RCD: CallingPackageName:"
-                + packageName);
     }
 
     /**
      * @hide
      */
     public void updateRemoteControllerOnExistingMediaPlayers() {
-        Log.v(TAG, "updateRemoteControllerOnExistingMediaPlayers: size of Player list: " +
+        synchronized(mMediaPlayers) {
+            Log.v(TAG, "updateRemoteControllerOnExistingMediaPlayers: size of Player list: " +
                                                                 mMediaPlayers.size());
-        if (mMediaPlayers.size() > 0) {
-            Log.v(TAG, "Inform RemoteController regarding existing RCC entry");
-            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
-            while (rccIterator.hasNext()) {
-                final MediaPlayerInfo player = rccIterator.next();
-                Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
-                intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME,
-                                                    player.getPackageName());
-                intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE,
-                                                    player.isFocussed());
-                intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, true);
-                sendBroadcastToAll(intent);
-                Log.v(TAG, "updating RCC change: CallingPackageName:" +
-                                                    player.getPackageName());
+            if (mMediaPlayers.size() > 0) {
+                Log.v(TAG, "Inform RemoteController regarding existing RCC entry");
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    final MediaPlayerInfo player = rccIterator.next();
+                    Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
+                    intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME,
+                                                        player.getPackageName());
+                    intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE,
+                                                        player.isFocussed());
+                    intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, true);
+                    sendBroadcastToAll(intent);
+                    Log.v(TAG, "updating RCC change: CallingPackageName:" +
+                                                        player.getPackageName());
+                }
+            } else {
+                Log.e(TAG, "No RCC entry present to update");
             }
-        } else {
-            Log.e(TAG, "No RCC entry present to update");
         }
     }
 
@@ -971,34 +975,36 @@ public class AudioService extends IAudioService.Stub {
      * @hide
      */
     public void removeMediaPlayerAndUpdateRemoteController (String packageName) {
-        Log.v(TAG, "removeMediaPlayerAndUpdateRemoteController: size of existing list: " +
-                                                                mMediaPlayers.size());
-        boolean playerToRemove = false;
-        int index = -1;
-        if (mMediaPlayers.size() > 0) {
-            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
-            while (rccIterator.hasNext()) {
-                index++;
-                final MediaPlayerInfo player = rccIterator.next();
-                if (packageName.equals(player.getPackageName())) {
-                    Log.v(TAG, "Player entry present remove and update RemoteController");
-                    playerToRemove = true;
-                    break;
-                } else {
-                    Log.v(TAG, "Player entry for " + player.getPackageName()+ " is not present");
+        synchronized(mMediaPlayers) {
+            Log.v(TAG, "removeMediaPlayerAndUpdateRemoteController: size of existing list: " +
+                                                                    mMediaPlayers.size());
+            boolean playerToRemove = false;
+            int index = -1;
+            if (mMediaPlayers.size() > 0) {
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    index++;
+                    final MediaPlayerInfo player = rccIterator.next();
+                    if (packageName.equals(player.getPackageName())) {
+                        Log.v(TAG, "Player entry present remove and update RemoteController");
+                        playerToRemove = true;
+                        break;
+                    } else {
+                        Log.v(TAG, "Player entry for " + player.getPackageName()+ " is not present");
+                    }
                 }
             }
+            if (playerToRemove) {
+                Log.e(TAG, "Removing Player: " + packageName + " from index" + index);
+                mMediaPlayers.remove(index);
+            }
+            Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
+            intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME, packageName);
+            intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE, false);
+            intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, false);
+            sendBroadcastToAll(intent);
+            Log.v(TAG, "Updated List size: " + mMediaPlayers.size());
         }
-        if (playerToRemove) {
-            Log.e(TAG, "Removing Player: " + packageName + " from index" + index);
-            mMediaPlayers.remove(index);
-        }
-        Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
-        intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME, packageName);
-        intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE, false);
-        intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, false);
-        sendBroadcastToAll(intent);
-        Log.v(TAG, "Updated List size: " + mMediaPlayers.size());
     }
 
     private void checkAllAliasStreamVolumes() {
diff --git a/services/core/java/com/android/server/display/WifiDisplayController.java b/services/core/java/com/android/server/display/WifiDisplayController.java
index 239f8cd..eaeca01 100644
--- a/services/core/java/com/android/server/display/WifiDisplayController.java
+++ b/services/core/java/com/android/server/display/WifiDisplayController.java
@@ -78,6 +78,9 @@ final class WifiDisplayController implements DumpUtils.Dump {
     private static final int RTSP_TIMEOUT_SECONDS = 30;
     private static final int RTSP_TIMEOUT_SECONDS_CERT_MODE = 120;
 
+    // time given for RTSP teardown sequence to complete.
+    private static final int RTSP_TEARDOWN_TIMEOUT = 3;
+
     // We repeatedly issue calls to discover peers every so often for a few reasons.
     // 1. The initial request may fail and need to retried.
     // 2. Discovery will self-abort after any group is initiated, which may not necessarily
@@ -151,6 +154,12 @@ final class WifiDisplayController implements DumpUtils.Dump {
     // True if RTSP has connected.
     private boolean mRemoteDisplayConnected;
 
+    // Waiting for displayDisconnected from ERD.
+    private boolean mRemoteDisplayTearingDown;
+
+    // Timed out waiting for RTSP teardown to complete.
+    private boolean mRemoteDisplayRtspTeardownTimedOut;
+
     // The information we have most recently told WifiDisplayAdapter about.
     private WifiDisplay mAdvertisedDisplay;
     private Surface mAdvertisedDisplaySurface;
@@ -363,7 +372,15 @@ final class WifiDisplayController implements DumpUtils.Dump {
     }
 
     private void updateScanState() {
-        if (mScanRequested && mWfdEnabled && mDesiredDevice == null) {
+
+        if (true == mRemoteDisplayTearingDown) {
+            // when rtsp teardown sequence is completed or timed out, this
+            // function will be called again.
+            Slog.i(TAG, "updateScanState no-op as rtsp teardown sequence is in progress");
+            return;
+        }
+
+        if (mScanRequested && mWfdEnabled && (mDesiredDevice == null)) {
             if (!mDiscoverPeersInProgress) {
                 Slog.i(TAG, "Starting Wifi display scan.");
                 mDiscoverPeersInProgress = true;
@@ -570,7 +587,7 @@ final class WifiDisplayController implements DumpUtils.Dump {
         // Step 1. Before we try to connect to a new device, tell the system we
         // have disconnected from the old one.
         if ((mRemoteDisplay != null || mExtRemoteDisplay != null) &&
-                mConnectedDevice != mDesiredDevice) {
+                mConnectedDevice != mDesiredDevice && false == mRemoteDisplayTearingDown) {
             Slog.i(TAG, "Stopped listening for RTSP connection on "
                     + mRemoteDisplayInterface
                     + " from Wifi display: " + mConnectedDevice.deviceName);
@@ -581,16 +598,25 @@ final class WifiDisplayController implements DumpUtils.Dump {
                 ExtendedRemoteDisplayHelper.dispose(mExtRemoteDisplay);
             }
 
-            mExtRemoteDisplay = null;
-            mRemoteDisplay = null;
-            mRemoteDisplayInterface = null;
-            mRemoteDisplayConnected = false;
             mHandler.removeCallbacks(mRtspTimeout);
+            mRemoteDisplayTearingDown = true;
 
-            mWifiP2pManager.setMiracastMode(WifiP2pManager.MIRACAST_DISABLED);
-            unadvertiseDisplay();
+            // Use extended timeout value for certification, as some tests require user inputs
+            int rtspTimeout = mWifiDisplayCertMode ?
+                RTSP_TIMEOUT_SECONDS_CERT_MODE : RTSP_TIMEOUT_SECONDS;
+
+            Slog.i(TAG, "Starting wait for rtsp teardown sequence for " +
+                   rtspTimeout + " secs");
 
-            // continue to next step
+            mHandler.postDelayed(mRtspTimeout, rtspTimeout * 1000);
+
+            return;
+        }
+
+        if (true == mRemoteDisplayTearingDown && false == mRemoteDisplayRtspTeardownTimedOut) {
+            // Need to wait for ERD to notify that p2p connection is no longer needed.
+            Slog.i(TAG, "updateConnection - return as rtsp teardown sequence in progress");
+            return;
         }
 
         // Step 2. Before we try to connect to a new device, disconnect from the old one.
@@ -630,6 +656,11 @@ final class WifiDisplayController implements DumpUtils.Dump {
             return; // wait for asynchronous callback
         }
 
+        if (true == mRemoteDisplayTearingDown) {
+            Slog.i(TAG, "rtsp teardown sequence in progress");
+            return;
+        }
+
         // Step 3. Before we try to connect to a new device, stop trying to connect
         // to the old one.
         if (mCancelingDevice != null) {
@@ -771,10 +802,11 @@ final class WifiDisplayController implements DumpUtils.Dump {
 
                 @Override
                 public void onDisplayDisconnected() {
+                    Slog.i(TAG, "onDisplayDisconnected called");
                     if (mConnectedDevice == oldDevice) {
                         Slog.i(TAG, "Closed RTSP connection with Wifi display: "
                                 + mConnectedDevice.deviceName);
-                        mHandler.removeCallbacks(mRtspTimeout);
+                        FinishRtspTeardown();
                         disconnect();
                     }
                 }
@@ -907,6 +939,21 @@ final class WifiDisplayController implements DumpUtils.Dump {
         }
     }
 
+    private void FinishRtspTeardown()
+    {
+        Slog.i(TAG, "Wait for rtsp teardown sequence completed");
+        mRemoteDisplayTearingDown = false;
+
+        mExtRemoteDisplay = null;  // callbacks no longer needed
+        mRemoteDisplay = null;
+        mRemoteDisplayInterface = null;
+        mRemoteDisplayConnected = false;
+        mHandler.removeCallbacks(mRtspTimeout);
+
+        mWifiP2pManager.setMiracastMode(WifiP2pManager.MIRACAST_DISABLED);
+        unadvertiseDisplay();
+    }
+
     private final Runnable mDiscoverPeers = new Runnable() {
         @Override
         public void run() {
@@ -929,13 +976,31 @@ final class WifiDisplayController implements DumpUtils.Dump {
     private final Runnable mRtspTimeout = new Runnable() {
         @Override
         public void run() {
+            Slog.i(TAG, "mRtspTimeout triggerred");
             if (mConnectedDevice != null
-                    && (mRemoteDisplay != null || mExtRemoteDisplay != null)
-                    && !mRemoteDisplayConnected) {
-                Slog.i(TAG, "Timed out waiting for Wifi display RTSP connection after "
-                        + RTSP_TIMEOUT_SECONDS + " seconds: "
-                        + mConnectedDevice.deviceName);
-                handleConnectionFailure(true);
+                    && (mRemoteDisplay != null || mExtRemoteDisplay != null)) {
+                if (true == mRemoteDisplayTearingDown) {
+                    // rtsp teardown sequence timed out
+                    Slog.i(TAG, "Timed out waiting for RTSP teardown sequence after "
+                           + RTSP_TEARDOWN_TIMEOUT + " seconds: "
+                           + mConnectedDevice.deviceName);
+                    mRemoteDisplayRtspTeardownTimedOut = true;
+
+                    // this should close P2P
+                    disconnect();
+
+                    FinishRtspTeardown();
+
+                    // Ok to resume wifi-scans
+                    updateConnection();
+                } else if (!mRemoteDisplayConnected) {
+                    Slog.i(TAG, "Timed out waiting for Wifi display RTSP connection after "
+                           + RTSP_TIMEOUT_SECONDS + " seconds: "
+                           + mConnectedDevice.deviceName);
+                    handleConnectionFailure(true);
+                } else {
+                    Slog.i(TAG, "Timed out. no-op");
+                }
             }
         }
     };
diff --git a/telephony/java/android/telephony/CarrierConfigManager.java b/telephony/java/android/telephony/CarrierConfigManager.java
index 74345e4..bd6662d 100644
--- a/telephony/java/android/telephony/CarrierConfigManager.java
+++ b/telephony/java/android/telephony/CarrierConfigManager.java
@@ -422,6 +422,13 @@ public class CarrierConfigManager {
     public static final String KEY_HIDE_IMS_APN_BOOL = "hide_ims_apn_bool";
 
     /**
+     * Determine whether HD icon should displayed when audio codec is EVS.
+     * @hide
+     */
+    public static final String KEY_IMS_SUPPORT_EVS_HD_ICON_BOOL =
+            "carrier_ims_support_evs_hd_icon_bool";
+
+    /**
      * Determine whether preferred network type can be shown.
      * @hide
      */
@@ -576,6 +583,7 @@ public class CarrierConfigManager {
         sDefaults.putBoolean(KEY_SUPPORT_CONFERENCE_CALL_BOOL, true);
         sDefaults.putBoolean(KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, true);
         sDefaults.putBoolean(KEY_HIDE_IMS_APN_BOOL, false);
+        sDefaults.putBoolean(KEY_IMS_SUPPORT_EVS_HD_ICON_BOOL, false);
         sDefaults.putBoolean(KEY_HIDE_PREFERRED_NETWORK_TYPE_BOOL, false);
         sDefaults.putBoolean(KEY_EDITABLE_WFC_MODE_BOOL, true);
         sDefaults.putInt(KEY_CDMA_DTMF_TONE_DELAY_INT, 100);
-- 
2.7.4

